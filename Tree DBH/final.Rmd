---
title: "final result"
output:
  word_document: default
  html_document: default
---

# data preparation
```{r}
setwd("C:/Users/YUHONG/Documents/R/DataScienceProject")
# load data
data = read.csv("datasets/all_plots.csv", stringsAsFactors = FALSE)
```

only extract DBH-related data for DBH modelling
```{r}
DBHdata = data[1:9]
```

check NAs and blank
```{r}
# blank "Large", assume "No" where it's blank
DBHdata[DBHdata$Large == "", "Tree.Number"]
DBHdata[DBHdata$Large == "", "Large"] = "No"
```
```{r}
# remove rows with NA in "DBH.year.6"
DBHdata[is.na(DBHdata$DBH.year.6), 1:7] # 9 NAs for "DBH.year.6"
DBHdata = DBHdata[!is.na(DBHdata$DBH.year.6), ]
```
#------------------------------------------------------------------------------------------
Referring to lower priority hypotheses: 
- The rate of natural mortality will be greater in control plots as compared to T1 and T2.
NOT satisfy: all blank Alive.at.year.6 are in T2:Radial.
#-------------------------------------------------------------------------------------------

```{r}
# remove rows with NA in "DBH.year.0"
DBHdata[is.na(DBHdata$DBH.year.0), 1:7] # 2 NAs for "DBH.year.0"
DBHdata = DBHdata[!is.na(DBHdata$DBH.year.0), ]
```
```{r}
# NA in "Class.year.0" and NA in "Class.year.6", no modification
DBHdata[is.na(DBHdata$Class.year.0) | is.na(DBHdata$Class.year.6), ]
# both in Plot5(T2: Radial), Tree.Number 148, 149, they have extremely large DBH.
```

make Treatment and Large factor
```{r}
DBHdata$Treatment = factor(DBHdata$Treatment)
DBHdata$Large = factor(DBHdata$Large)
```

rows where DBH.year.6 <= DBH.year.0 (tree growth <= 0)
```{r}
DBHdata[DBHdata$DBH.year.6 <= DBHdata$DBH.year.0, ]
```






# data analysis
```{r}
# points outside the main group
par(mfrow=c(1,2))
plot(DBHdata$DBH.year.0, DBHdata$DBH.year.6, type = "p", col = factor(DBHdata$DBH.year.6/DBHdata$DBH.year.0 > 1.25 | DBHdata$DBH.year.6/DBHdata$DBH.year.0 < 0.9 | DBHdata$DBH.year.0 > 80))
plot(DBHdata$DBH.year.0, DBHdata$DBH.year.6/DBHdata$DBH.year.0, type = "p", col = factor(DBHdata$DBH.year.6/DBHdata$DBH.year.0 > 1.25 | DBHdata$DBH.year.6/DBHdata$DBH.year.0 < 0.9 | DBHdata$DBH.year.0 > 80), ylab = "gradient")
DBHdata[DBHdata$DBH.year.6/DBHdata$DBH.year.0 > 1.25 | DBHdata$DBH.year.6/DBHdata$DBH.year.0 < 0.9 | DBHdata$DBH.year.0 > 80, ]

# remove these outliers
DBHdatarm = DBHdata[DBHdata$DBH.year.6/DBHdata$DBH.year.0 < 1.25 & DBHdata$DBH.year.6/DBHdata$DBH.year.0 > 0.9 & DBHdata$DBH.year.0 < 80, ]
```

```{r}
cor(DBHdata$DBH.year.0, DBHdata$DBH.year.6)
cor(log(DBHdata$DBH.year.0), log(DBHdata$DBH.year.6))

cor(DBHdatarm$DBH.year.0, DBHdatarm$DBH.year.6)
cor(log(DBHdatarm$DBH.year.0), log(DBHdatarm$DBH.year.6))
```






# random effect
```{r}
par(mfrow=c(3,4))
for (i in 1:12) {
  plot(DBHdata[DBHdata$Plot == i, "DBH.year.0"], DBHdata[DBHdata$Plot == i, "DBH.year.6"], xlab = paste("Plot", i, "DBH.year.0"), ylab = paste("Plot", i, "DBH.year.6"), xlim = c(20,70), ylim = c(20,70), col = DBHdata[DBHdata$Plot == i, "Treatment"])
  abline(0,1)
}

for (i in 1:12) {
  plot(log(DBHdata[DBHdata$Plot == i, "DBH.year.0"]), log(DBHdata[DBHdata$Plot == i, "DBH.year.6"]), xlab = paste("Plot", i, "log(DBH.year.0)"), ylab = paste("Plot", i, "log(DBH.year.6)"), xlim = c(3.0,4.3), ylim = c(3.0, 4.3), col = DBHdata[DBHdata$Plot == i, "Treatment"])
  abline(0,1)
}
```






# "In Gap" term
add "InGap" term
```{r}
DBHdatarm$InGap = (DBHdatarm$Treatment == "T2: Radial" & DBHdatarm$Large == "Yes")
```
make InGap factor
```{r}
DBHdatarm$InGap = factor(DBHdatarm$InGap)
```






# current final model
random effect using InGap for log(DBHdatarm$DBH.year.6)
```{r}
library(lme4)
mixed2.0 = lmer(log(DBH.year.6)~log(DBH.year.0)+Treatment+InGap+log(DBH.year.0):InGap+(1|Plot), data = DBHdatarm)
summary(mixed2.0)
VarCorr(mixed2.0)
y.hat <- fitted(mixed2.0) # Fitted values
int.hat <- ranef(mixed2.0)[[1]][[1]] # Predicted intercepts
res.hat <- residuals(mixed2.0) # Estimated residuals
tss = sum((log(DBHdatarm$DBH.year.6)-mean(log(DBHdatarm$DBH.year.6)))^2) #TSS
rss = sum((log(DBHdatarm$DBH.year.6)-y.hat)^2) #RSS
(tss-rss)/tss #R^2 = 0.9801595
```
```{r}
qqnorm(int.hat, main="Random Intercepts"); qqline(int.hat)
qqnorm(res.hat, main="Residuals"); qqline(res.hat)
plot(y.hat, res.hat, xlab="Fitted Values", ylab="Residuals")
abline(h=0, lty=2)
plot(log(DBHdatarm$DBH.year.6), y.hat, col = DBHdatarm$Treatment)
abline(0, 1)
plot(log(DBHdatarm$DBH.year.6), y.hat, col = DBHdatarm$Large)
abline(0, 1)
plot(log(DBHdatarm$DBH.year.6), y.hat, col = DBHdatarm$InGap)
abline(0, 1)
```






# visualization
```{r}
# add tree growth attribute
DBHdata$Tree.growth = DBHdata$DBH.year.6-DBHdata$DBH.year.0

# plot tree growth for large VS not-large trees using all data
plot(DBHdata$DBH.year.0, DBHdata$Tree.growth, col = DBHdata$Large, ylim = c(-10,20))
legend("topright", legend = c("large", "not large"), fill = c("red", "black"), cex = 0.8)

# plot tree growth for large VS not-large trees across three treatments
plot(DBHdata[DBHdata$Treatment == "Control", "DBH.year.0"], DBHdata[DBHdata$Treatment == "Control", "Tree.growth"], col = DBHdata[DBHdata$Treatment == "Control", "Large"], xlab = "Control DBH.year.0", ylab = "Control tree growth", ylim = c(-10,20))
legend("topright", legend = c("large", "not large"), fill = c("red", "black"), cex = 0.8)

plot(DBHdata[DBHdata$Treatment == "T1: Gap", "DBH.year.0"], DBHdata[DBHdata$Treatment == "T1: Gap", "Tree.growth"], col = DBHdata[DBHdata$Treatment == "T1: Gap", "Large"], xlab = "T1 DBH.year.0", ylab = "T1 tree growth", ylim = c(-10,20))
legend("topright", legend = c("large", "not large"), fill = c("red", "black"), cex = 0.8)

plot(DBHdata[DBHdata$Treatment == "T2: Radial", "DBH.year.0"], DBHdata[DBHdata$Treatment == "T2: Radial", "Tree.growth"], col = DBHdata[DBHdata$Treatment == "T2: Radial", "Large"], xlab = "T2 DBH.year.0", ylab = "T2 tree growth", ylim = c(-10,20))
legend("topright", legend = c("large", "not large"), fill = c("red", "black"), cex = 0.8)
```

```{r}
# plot constrains according to mixed2.0
plot(DBHdatarm$DBH.year.0, DBHdatarm$DBH.year.6, col = DBHdatarm$InGap, xlim = c(20,80))
abline(v = 52.76, col = "blue") # constrain for T2InGap > T2 not InGap
abline(v = 57.87, col = "green") # constrain for T2InGap > T1
abline(v = 74.42, col = "orange") # constrain for T2InGap > Control
legend("topleft", c("InGap points", "not InGap points", "InGap>T2notInGap constrain", "InGap>T1 constrain", "InGap>Control constrain"), fill = c("black", "red", "blue", "green", "orange"), cex = 0.9)
```
Interpretation for the constrains: sparse data in the constrain region, so the fitted model cannot explain well. If more data is obtained in the future, results would be more realistic.

```{r}
library(merTools)
X_ingap <- data.frame('DBH.year.0'=1:100, 'InGap'=TRUE, 'Plot'=6, 'Treatment'='T2: Radial')
PI_2 <- predictInterval(merMod = mixed2.0, newdata = X_ingap, level = 0.95, n.sims = 1000, stat = "median", type="linear.prediction", include.resid.var = TRUE)


for (t in c("Control", "T1: Gap", "T2: Radial")) {
  X <- data.frame('DBH.year.0'=1:100, 'InGap'=FALSE, 'Plot'=6, 'Treatment'=t)
  PI <- predictInterval(merMod = mixed2.0, newdata = X, level = 0.95, n.sims = 1000, stat = "median", type="linear.prediction", include.resid.var = TRUE)
  
  plot(1:100, exp(PI$fit), type='n', xlim=c(20,60), ylim = c(10,80), xlab = "DBH.year.0", ylab = "predicted DBH.year.6")
  polygon(c(1:100, 100:1), c(exp(PI$upr), rev(exp(PI$lwr))), col = "light grey", border = "light grey")
  lines(1:100, exp(PI$fit), type = "l")
  polygon(c(1:100, 100:1), c(exp(PI_2$upr), rev(exp(PI_2$lwr))), col = rgb(255,0,0, 50, maxColorValue = 255), border = rgb(255,0,0, 50, maxColorValue = 255))
  lines(1:100, exp(PI_2$fit), type = "l", col = "red")
  legend("topleft", legend = c("InGap", t), fill = c("red", "black"))
}
```
Here, The first plot InGap VS Control is possibly a useful visualization for the mixed2.0 model to show how InGap increase tree growth compared to Control. The intersections of red lines and black lines in the second and third plot deliver the same information as the vertical constrain lines in the previous plot.

```{r}
treatments = c("Control", "T1: Gap", "T2: Radial")
shades = c("light grey", rgb(255,0,0, 50, maxColorValue = 255), rgb(0,255,0, 50, maxColorValue = 255))
colours = c("black", "red", "green")

plot(1:100, exp(PI$fit), type='n', xlim=c(20,60), ylim = c(10,80), xlab = "DBH.year.0", ylab = "predicted DBH.year.6")
for (i in 1:3) {
  X <- data.frame('DBH.year.0'=1:100, 'InGap'=FALSE, 'Plot'=6, 'Treatment'=treatments[i])
  PI <- predictInterval(merMod = mixed2.0, newdata = X, level = 0.95, n.sims = 1000, stat = "median", type="linear.prediction", include.resid.var = TRUE)
  
  polygon(c(1:100, 100:1), c(exp(PI$upr), rev(exp(PI$lwr))), col = shades[i], border = shades[i])
  lines(1:100, exp(PI$fit), type = "l", col = colours[i])
}
legend("topleft", legend = treatments, fill = colours)
```
This plot shows fitted line and 95% predict interval for not-InGap trees in the three treatments.
The red line(T1) and the green line(T2) are both higher and steeper than the black line(Control), but lines and shaded intervals of T1 and T2 almost completely overlap. 

Interpretation for this overlap:
1. What does these two groups refer to? 
    -> red: T1 & not-InGap = all T1 trees = trees around the T1gap area + trees not around the T1gap area(which could be considered as naturally distributed as in Control)
    -> green: T2 & not-InGap = trees except for the one in the middle of the T2radial area = trees around the T2radial area + trees not around the T2radial area.
No matter it's a T1gap area or a T2radial area, it's always an open space, SO basically, trees in the red groups and in the green groups could be considered as having the same "treatment"(distribution) situations. SO having almost completely overlapping shades and lines is reasonable.
2. In the perspective of the estimated parameter values for these two terms:
    -> TreatmentT1: Gap is 0.028683, TreatmentT2: Rad is 0.039231
Calculating back the log(), T1 contributes exp(0.028683)=1.029 gradient, T2 contributes exp(0.039231)=1.04 gradient. 1.029 is very close to 1.04. Also, intercepts for the lines are very very close to each other as well, SO the red and green lines and their shades are almost completely overlapping is still reasonable.
3. Compared to Control:
Despite of how overlapping T1 and T2 are in the plot, one point is obvious: they are both clearly higher and steeper than Control. This gives T1, T2 > Control
4. Although T1 and T2 only have tiny difference, I think it's still necessary to use the estimated parameter values to conclude that T2 > T1 in terms of tree growth.
    -> thinking in percentage: For trees starting with the same DBH.year.0 value, being in T1 will have a 2.9% increase in DBH.year.6 value compared to DBH.year.6 in Control; and being in T2 will have a 4% increase in DBH.year.6 value compared to DBH.year.6 in Control. And 2.9% is clearly different from 4%.



# other plots
```{r}
plot(DBHdatarm[DBHdatarm$Treatment == "Control", "DBH.year.0"], DBHdatarm[DBHdatarm$Treatment == "Control", "DBH.year.6"], xlim = c(20,70), ylim = c(20,70), xlab = "DBHdatarm$DBH.year.0", ylab = "DBHdatarm$DBH.year.6")
points(DBHdatarm[DBHdatarm$InGap == TRUE, "DBH.year.0"], DBHdatarm[DBHdatarm$InGap == TRUE, "DBH.year.6"], col = "red")
legend("bottomright", legend = c("Control", "InGap"), fill = c("black", "red"))

plot(DBHdatarm[DBHdatarm$Treatment == "T1: Gap", "DBH.year.0"], DBHdatarm[DBHdatarm$Treatment == "T1: Gap", "DBH.year.6"], xlim = c(20,70), ylim = c(20,70), xlab = "DBHdatarm$DBH.year.0", ylab = "DBHdatarm$DBH.year.6")
points(DBHdatarm[DBHdatarm$InGap == TRUE, "DBH.year.0"], DBHdatarm[DBHdatarm$InGap == TRUE, "DBH.year.6"], col = "red")
legend("bottomright", legend = c("T1: Gap", "InGap"), fill = c("black", "red"))

plot(DBHdatarm[DBHdatarm$Treatment == "T2: Radial", "DBH.year.0"], DBHdatarm[DBHdatarm$Treatment == "T2: Radial", "DBH.year.6"], xlim = c(20,70), ylim = c(20,70), xlab = "DBHdatarm$DBH.year.0", ylab = "DBHdatarm$DBH.year.6")
points(DBHdatarm[DBHdatarm$InGap == TRUE, "DBH.year.0"], DBHdatarm[DBHdatarm$InGap == TRUE, "DBH.year.6"], col = "red")
legend("bottomright", legend = c("T2: Radial", "InGap"), fill = c("black", "red"))
```
```{r}
plot(DBHdatarm[DBHdatarm$Treatment != "T2: Radial", "DBH.year.0"], DBHdatarm[DBHdatarm$Treatment != "T2: Radial", "DBH.year.6"], col = DBHdatarm[DBHdatarm$Treatment != "T2: Radial", "Treatment"])

plot(DBHdatarm[DBHdatarm$Treatment != "T1: Gap", "DBH.year.0"], DBHdatarm[DBHdatarm$Treatment != "T1: Gap", "DBH.year.6"], col = DBHdatarm[DBHdatarm$Treatment != "T1: Gap", "Treatment"])
```



Nick's additional code to test T2 > T1:
```{r}
library(car)

# Matrix to set up the hypothesis 
# H0: Beta_T1 - Beta_T2 = 0
C <- matrix(c(0,0,1,-1,0,0),1,6)

linearHypothesis(mixed2.0, C)
# We don't reject H0 at a 5% or 10% significance level
```
